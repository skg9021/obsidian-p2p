import * as Y from 'yjs';
import { App, TFile, TAbstractFile, debounce, Notice } from 'obsidian';
// @ts-ignore - no types for this package
import { TrysteroProvider } from '@winstonfassett/y-webrtc-trystero';
// @ts-ignore
import { joinRoom, closeAllClients } from 'trystero/mqtt';
// @ts-ignore
import { WebrtcProvider } from 'y-webrtc';
import * as awarenessProtocol from 'y-protocols/awareness';
import { P2PSettings } from '../settings';
import { joinRoom as joinLocalRoom } from './trystero-local-strategy';
import { ProviderManager } from './provider-manager.service';
import { PeerInfo } from './p2p-types';





export class YjsService {
    ydoc: Y.Doc;
    yMap: Y.Map<Y.Text>;
    /** Tombstone map: path → { deletedBy, deletedAt } for soft-delete propagation */
    tombstones: Y.Map<any>;
    awareness: awarenessProtocol.Awareness;
    isRemoteUpdate: boolean = false;

    /** Paths deleted locally — prevents applyToDisk from recreating them even if CRDT merge re-introduces the key */
    private pendingDeletes: Set<string> = new Set();

    /** Provider Manager handling strategies */
    providerManager: ProviderManager;

    /** Callback when peer list changes */
    onPeersUpdated: (peers: PeerInfo[]) => void = () => { };

    constructor(private app: App, private settings: P2PSettings) {
        this.ydoc = new Y.Doc();
        this.yMap = this.ydoc.getMap('obsidian-vault');
        this.tombstones = this.ydoc.getMap('deleted-files');

        // Shared awareness instance — used by strategies
        this.awareness = new awarenessProtocol.Awareness(this.ydoc);

        // Set our own device name in awareness
        this.awareness.setLocalState({
            name: this.settings.deviceName,
            color: this.settings.userColor,
        });

        // Initialize Provider Manager
        this.providerManager = new ProviderManager();
        this.providerManager.onPeersUpdated = (peers) => {
            this.log(`Peers updated: [${peers.map(p => `${p.name}(${p.source})`).join(', ')}]`);
            this.onPeersUpdated(peers);
        };

        this.ydoc.on('update', (update: Uint8Array, origin: any) => {
            if (origin === 'local') {
                this.log(`Outgoing Yjs Update: ${update.length} bytes generated by local edit`);
            } else {
                this.log(`Incoming Yjs Update: ${update.length} bytes received from peer`);
                this.applyToDisk();
            }
        });

        // Directly observe the tombstones map so remote deletions are always processed,
        // even if applyToDisk was recently debounced away.
        this.tombstones.observe((event) => {
            const keys = Array.from(event.keysChanged);
            console.log(`[P2P Yjs] tombstones.observe fired: origin=${event.transaction.origin}, keys=${JSON.stringify(keys)}`);
            if (event.transaction.origin !== 'local') {
                console.log(`[P2P Yjs] Remote tombstone detected, scheduling applyToDisk in 600ms`);
                setTimeout(() => this.applyToDisk(), 600);
            }
        });
    }

    private log(msg: string, ...args: any[]) {
        if (this.settings.enableDebugLogs) console.log(`[P2P Yjs] ${msg}`, ...args);
    }

    /** Set local IPs in awareness so other peers can see our IP */
    setLocalIPs(ips: string[]) {
        const currentState = this.awareness.getLocalState() || {};
        this.awareness.setLocalState({
            ...currentState,
            ip: ips.length > 0 ? ips[0] : undefined,
        });
    }

    /** Public method to re-emit the current peer list (e.g. after reconnect) */
    refreshPeerList() {
        const peers = this.providerManager.getPeers();
        this.onPeersUpdated(peers);
    }

    /** 
     * Helper to determine the best provider for a given client ID 
     * (Delegated to Provider Mananger's source info)
     */
    getClientProvider(clientId: number): 'mqtt' | 'local' | null {
        const peers = this.providerManager.getPeers();
        const peer = peers.find(p => p.clientId === clientId);
        if (!peer) return null;

        if (peer.source === 'both') return 'local';
        if (peer.source === 'internet') return 'mqtt';
        if (peer.source === 'local') return 'local';
        return null;
    }

    // ─── Lifecycle ──────────────────────────────────────────────

    destroy() {
        this.providerManager.destroy();
        this.awareness.destroy();
        this.ydoc.destroy();
    }

    // ─── Vault ↔ Yjs sync ───────────────────────────────────────

    /**
     * Soft-delete: places a tombstone in the shared CRDT so all peers
     * move the file to trash instead of hard-deleting it.
     */
    handleLocalDelete(file: TAbstractFile) {
        if (this.isRemoteUpdate) {
            console.log(`[P2P Yjs] handleLocalDelete SKIPPED (isRemoteUpdate): ${file instanceof TFile ? file.path : 'not-a-file'}`);
            return;
        }
        if (!(file instanceof TFile)) return;

        console.log(`[P2P Yjs] handleLocalDelete: soft-deleting ${file.path} (ext=${file.extension})`);

        // Guard: prevent applyToDisk from recreating this file even if CRDT merge re-introduces it
        this.pendingDeletes.add(file.path);

        this.ydoc.transact(() => {
            // Only remove from yMap if it's a markdown file (yMap only stores .md content)
            if (file.extension === 'md') {
                this.yMap.delete(file.path);
            }
            this.tombstones.set(file.path, {
                deletedBy: this.settings.deviceName,
                deletedAt: Date.now(),
            });
        }, 'local');
        console.log(`[P2P Yjs] Tombstone set. Current tombstones: [${Array.from(this.tombstones.keys()).join(', ')}]`);
    }

    async handleLocalModify(file: TAbstractFile) {
        if (this.isRemoteUpdate) return;
        if (!(file instanceof TFile) || file.extension !== 'md') return;

        const content = await this.app.vault.read(file);

        this.ydoc.transact(() => {
            // Only clear tombstones that are old (>10s).
            // Fresh tombstones were just set by a delete and might be re-triggered
            // by applyToDisk creating the file (which fires a 'create' event).
            if (this.tombstones.has(file.path)) {
                const meta = this.tombstones.get(file.path);
                const age = Date.now() - (meta?.deletedAt || 0);
                if (age > 10000) {
                    this.log(`Clearing old tombstone for ${file.path} (age=${Math.round(age / 1000)}s, file recreated by user)`);
                    this.tombstones.delete(file.path);
                    this.pendingDeletes.delete(file.path);
                } else {
                    this.log(`Ignoring fresh tombstone for ${file.path} (age=${Math.round(age / 1000)}s)`);
                    return; // Don't re-add the file to yMap
                }
            }

            let yText = this.yMap.get(file.path);
            if (!yText) {
                yText = new Y.Text();
                this.yMap.set(file.path, yText);
            }

            const yContent = yText.toString();
            if (yContent !== content) {
                this.updateYText(yText, content);
            }
        }, 'local');
    }

    applyToDisk = debounce(async () => {
        this.isRemoteUpdate = true;
        try {
            // 1) Apply content updates (create / modify)
            for (const [path, yText] of this.yMap.entries()) {
                // Skip files with active tombstones
                if (this.tombstones.has(path)) continue;
                // Skip files deleted locally (protects against CRDT merge re-introducing the key)
                if (this.pendingDeletes.has(path)) continue;

                const content = (yText as Y.Text).toString();
                const file = this.app.vault.getAbstractFileByPath(path);
                if (file instanceof TFile) {
                    const current = await this.app.vault.read(file);

                    // Race condition guard: If Yjs gives us an empty string but the local file 
                    // has content, it's likely a CRDT initialization sync delay. Since we use
                    // tombstones for explicit deletions, a blank yText is almost certainly a sync artifact.
                    if (content === '' && current.length > 0) {
                        this.log(`Ignoring empty CRDT update for ${path} (local length: ${current.length}) to prevent blanking`);
                        continue;
                    }

                    if (current !== content) await this.app.vault.modify(file, content);
                } else if (!file) {
                    await this.ensureFolder(path);
                    await this.app.vault.create(path, content);
                }
            }

            // 2) Apply tombstones — move deleted files to Obsidian's trash
            for (const [path, meta] of this.tombstones.entries()) {
                const file = this.app.vault.getAbstractFileByPath(path);
                if (file instanceof TFile) {
                    this.log(`Moving ${path} to trash (deleted by ${meta.deletedBy} at ${new Date(meta.deletedAt).toLocaleString()})`);
                    new Notice(`"${path}" was deleted by ${meta.deletedBy} and moved to trash`);
                    await this.app.vault.trash(file, false);
                }

                // Clean up yMap if CRDT merge re-introduced the key
                if (this.yMap.has(path)) {
                    this.ydoc.transact(() => {
                        this.yMap.delete(path);
                    }, 'local');
                }
            }
        } catch (e) { console.error("Sync Write Error", e); }
        finally { this.isRemoteUpdate = false; }
    }, 500, true);

    async syncLocalToYjs() {
        const files = this.app.vault.getMarkdownFiles();
        this.ydoc.transact(() => {
            files.forEach(async (file) => {
                // Skip files with active tombstones
                if (this.tombstones.has(file.path)) return;

                const content = await this.app.vault.read(file);
                let yText = this.yMap.get(file.path);

                if (!yText) {
                    yText = new Y.Text();
                    this.yMap.set(file.path, yText);
                }

                if (yText.toString() !== content) {
                    this.updateYText(yText, content);
                }
            });
        }, 'local');
    }

    /**
     * Updates a Y.Text object with new content by computing a fast prefix/suffix diff.
     * This prevents sending the entire document over the network on every keystroke,
     * which can buffer overflow and stall WebRTC DataChannels.
     */
    private updateYText(yText: Y.Text, newContent: string) {
        const oldContent = yText.toString();
        if (oldContent === newContent) return;

        // Find common prefix
        let start = 0;
        while (start < oldContent.length && start < newContent.length && oldContent[start] === newContent[start]) {
            start++;
        }

        // Find common suffix
        let end = 0;
        while (
            end < oldContent.length - start &&
            end < newContent.length - start &&
            oldContent[oldContent.length - 1 - end] === newContent[newContent.length - 1 - end]
        ) {
            end++;
        }

        const deleteLength = oldContent.length - start - end;
        if (deleteLength > 0) {
            yText.delete(start, deleteLength);
        }

        const insertString = newContent.substring(start, newContent.length - end);
        if (insertString.length > 0) {
            yText.insert(start, insertString);
        }
    }

    async ensureFolder(path: string) {
        const parts = path.split('/');
        parts.pop();
        let current = '';
        for (const part of parts) {
            current = current ? `${current}/${part}` : part;
            if (!this.app.vault.getAbstractFileByPath(current)) await this.app.vault.createFolder(current);
        }
    }
}
